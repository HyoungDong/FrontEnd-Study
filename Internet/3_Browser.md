## 브라우저와 동작 원리

## 브라우저의 주요 기능

사람마다 브라우저를 사용하는 용도는 다를 것이다. 하지만 브라우저가 하는 일은 같다. **사용자가 원하는 자원(HTML, PDF 등.)을 찾아서 보여주는 일을 하는 것이다.** 구글에서 무언가를 검색한다고 가정해보자. 우리가 원하는 것은 무엇일까? 바로 검색한 키워드에 대한 정보이다. 일단 사용자는 주소 표시줄에 www.google.com을 입력하고 엔터키를 누를 것이다. 그럼 어떻게 보여주는지는 모르겠지만 브라우저는 구글의 첫 화면을 우리에게 보여줄 것이다. 그리고나서 검색창에 키워드를 입력하고 검색 버튼을 누르면 또 화면이 바뀐다. 주소창에 있는 URL 또한 바뀐다. 주소가 바뀌었다는건 구글 검색 버튼이 어떤 주소로 연결해주었기 때문이라고 짐작할 수 있다. 그런데 브라우저는 어떻게 주소에 해당하는 페이지를 보여주는 것일까?

## 브라우저의 기본 구조

- 브라우저의 주요 구성 요소는 다음과 같다.
  - 사용자 인터페이스 : 주소 표시줄, 이전/다음 버튼, 북마크 메뉴 등. 요청한 페이지를 보여주는 창을 제외한 나머지 모든 부분.
  - 브라우저 엔진 : 사용자 인터페이스와 렌더링 엔진 사이의 동작을 제어.
  - 렌더링 엔진 : 요청한 콘텐츠를 표시. ex) HTML을 요청하면 HTML과 CSS를 파싱 하여 화면에 표시. 파이어폭스는 모질라에서 만든 게코(Gecko) 엔진, 사파리와 크롬은 웹킷(Webkit) 엔진을 사용한다. 크롬은 다른 브라우저들과 달리 각 탭마다 별도의 렌더링 엔진 인스턴스를 유지한다. 또 나은 사용자 경험을 위해 HTML 파싱을 기다리지 않고 받은 내용의 일부를 먼저 화면에 표시한다.
  - 통신 : HTTP 요청과 같은 네트워크 호출에 사용됨.
  - UI 백엔드 : 콤보 박스와 창 같은 기본적인 장치를 그림. 플랫폼에서 명시하지 않은 일반적인 인터페이스로서, 운영체제 사용자 인터페이스 체계를 사용.
  - 자바스크립트 해석기 : 자바스크립트 코드를 해석하고 실행.
  - 자료 저장소 : 자료를 저장하는 계층. 쿠키를 저장하는 것과 같이 모든 종류의 자원을 하드디스크에 저장할 필요가 있음. HTML5 명세에는 브라우저가 지원하는 '웹 데이터 베이스'가 정의되어있음.

![image alt](https://img1.daumcdn.net/thumb/R1280x0/?scode=mtistory2&fname=https%3A%2F%2Fblog.kakaocdn.net%2Fdn%2Fbux4a9%2FbtqtZO4Zp3P%2FbKSqTgKzNG5JCZ2vGGKPUK%2Fimg.png)

## 레더링 엔진

렌더링 엔진의 역할은 **요청 받은 내용을 브라우저 화면에 표시하는 일이다.**

렌더링 엔진은 HTML 및 XML 문서와 이미지를 표시할 수 있다. 물론 플러그인이나 브라우저 확장 기능을 이용해 PDF와 같은 다른 유형도 표시할 수 있다. 우선은 HTML과 이미지를 CSS로 표시하는 주된 사용 패턴에 초점을 맞추어 알아보자.

### 동작과정

렌더링 엔진은 통신으로부터 요청한 문서의 내용을 얻는 것으로 시작하는데 문서의 내용은 보통 8KB 단위로 전송된다.

다음은 렌더링 엔진의 기본적인 동작 과정이다.
<br/>
![image alt](https://d2.naver.com/content/images/2015/06/helloworld-59361-2.png)

**1. DOM 트리 구축 위한 HTML 파싱 + CSSOM (CSS Object Model) 구축 위한 스타일 파싱**

- 파싱 : 파싱은 어휘 분석/구문 분석으로 구분. 어휘 분석은 자료를 토큰으로 분해하는 과정. 토큰은 유효하게 구성된 단위의 집합체로, 인간의 언어로 예를 들면 사전에 등장하는 모든 단어에 해당한다. 구문 분석은 언어의 구문 규칙을 적용하는 과정.

- DOM Tree 생성 과정

  - 1. 변환 : 브라우저가 원시바이트(Bytes)를 디스크나 네트워크에서 읽어와 해당 파일에 지정된 인코딩(ex. UTF-8)에 따라 개별 문자로 변환한다.
  - 2. 토큰화 : 브라우저가 문자열을 W3C 표준에 지정된 고유 토큰(<html>, <body> 같은 형태의 문자)으로 변환한다. 토큰은 특별한 의미와 고유의 규칙을 갖는다.
  - 3. 렉싱(Tokens > Nodes) : 방출된 토큰은 속성 및 규칙을 정의하는 객체로 변환한다.
  - 4. DOM 생성 : HTML 마크업이 여러 태그간의 관계를 정의하면서 트리 구조를 형성한다.

    ![image alt](https://user-images.githubusercontent.com/35126809/90095244-072f4900-dd6b-11ea-9a7d-d2eb219c3399.png)

    **DOM?**
    문서 객체 모델(The Document Object Model, 이하 DOM) 은 HTML, XML 문서의 프로그래밍 interface 이다.

    DOM은 문서의 구조화된 표현(structured representation)을 제공하며 프로그래밍 언어가 DOM 구조에 접근할 수 있는 방법을 제공하여 그들이 문서 구조, 스타일, 내용 등을 변경할 수 있게 돕는다.

    DOM 이 없다면 자바스크립트 언어는 웹 페이지 또는 XML 페이지 및 요소들과 관련된 모델이나 개념들에 대한 정보를 갖지 못하게 된다.

    DOM은 프로그래밍 언어가 자신에 접근하고 수정할 수 있는 방법을 제공하는데 일반적으로 프로퍼티와 메소드를 갖는 자바스크립트 객체로 제공된다. 이를 DOM API(Application Programming Interface)라고 부른다. 달리 말하면 정적인 웹페이지에 접근하여 동적으로 웹페이지를 변경하기 위한 유일한 방법은 메모리 상에 존재하는 DOM을 변경하는 것이고, 이때 필요한 것이 DOM에 접근하고 변경하는 프로퍼티와 메소드의 집합인 DOM API이다.

    **DOM tree?**

    DOM tree는 브라우저가 HTML 문서를 로드한 후 파싱하여 생성하는 모델을 의미한다. 객체의 트리로 구조화되어 있기 때문에 DOM tree라 부른다.
    DOM은 마크업과 1:1의 관계를 맺는다.
    <br/>
    ![](https://i.imgur.com/gA01Wci.png)
    <br/>
    ![image alt](https://poiemaweb.com/img/dom-tree.png)


      DOM tree 는 네 종류의 노드로 구성된다.

      - ***`문서 노드(Document Node)`***<br/>
      `트리의 최상위에 존재하며 각각 요소, 어트리뷰트, 텍스트 노드에 접근하려면 문서 노드를 통해야 한다. 즉, DOM tree에 접근하기 위한 시작점(entry point)이다.`
     - ***`요소 노드(Element Node)`***<br/>
    `요소 노드는 HTML 요소를 표현한다. HTML 요소는 중첩에 의해 부자 관계를 가지며 이 부자 관계를 통해 정보를 구조화한다. 따라서 요소 노드는 문서의 구조를 서술한다고 말 할 수 있다. 어트리뷰트, 텍스트 노드에 접근하려면 먼저 요소 노드를 찾아 접근해야 한다. 모든 요소 노드는 요소별 특성을 표현하기 위해 HTMLElement 객체를 상속한 객체로 구성된다. (그림: DOM tree의 객체 구성 참고)`
     - ***`어트리뷰트 노드(Attribute Node)`*** <br/>
    `어트리뷰트 노드는 HTML 요소의 어트리뷰트를 표현한다. 어트리뷰트 노드는 해당 어트리뷰트가 지정된 요소의 자식이 아니라 해당 요소의 일부로 표현된다. 따라서 해당 요소 노드를 찾아 접근하면 어트리뷰트를 참조, 수정할 수 있다.`
    - ***`텍스트 노드(Text Node)`***<br/>
    `텍스트 노드는 HTML 요소의 텍스트를 표현한다. 텍스트 노드는 요소 노드의 자식이며 자신의 자식 노드를 가질 수 없다. 즉, 텍스트 노드는 DOM tree의 최종단이다.`
        <br/><br/>
        DOM에서 모든 요소, 어트리뷰트, 텍스트는 하나의 객체이며 Document 객체의 자식이다. 요소의 중첩관계는 객체의 트리로 구조화하여 부자관계를 표현한다. DOM tree의 진입점(Entry point)는 document 객체이며 최종점은 요소의 텍스트를 나타내는 객체이다.
        <br/><br/><br/>
        **CSSOM (CSS Object Model)?**
        - 브라우저가 HTML을 파싱하는 과정에서 대부분은 head 태그의 하위로 link 태그가 존재해 CSS 파일을 불러오게 된다. CSS 파일을 불러온 뒤, HTML과 마찬가지로 브라우저가 이해하고 처리할 수 있는 형식으로 변환해야 한다. 그 과정은 DOM을 생성하는 과정과 동일하다. 단 출력된 결과는 CSSOM(CSS Object Model) 이라고 부르며, DOM 트리와 마찬가지로 트리 구조로 되어있어 CSSOM 트리 라고도 부른다.

        ![image alt](https://memory.today/dev/36/cssom-tree.png)

**2. 렌더 트리 구축**

- 앞서 만든 DOM 트리와, CSSOM 트리는 서로 연관이 없는 독립적인 객체이다. DOM 트리는 콘텐츠를 의미하고, CSSOM은 문서에 적용되어야 하는 스타일 규칙을 의미한다. 따라서 두 번째 단계에선 이 두 개의 트리를 결합하여 렌더 트리를 생성한다.
  <br/>
  ![image alt](https://memory.today/dev/36/render-tree.png)

- 렌더 트리는 DOM 트리의 최상위 노드부터 각각의 노드를 탐색하여 렌더링에 필요한 노드들을 CSSOM 트리와 일치시켜 생성한다. 그리고 DOM 트리를 탐색하는 과정에서 렌더링 출력에 반영되지 않는 불필요한 노드들은 건너뛰게 된다. 예를들면 `<script>` 태그나, `<meta>` 태그 같은 것들이 있다.
  또한 display:none 처럼 CSS를 통해 렌더링 출력에 반영되지 않는 노드들도 실제 화면에서 렌더링이 되지 않기 때문에 렌더 트리에서 제외된다.
  다만 visibility:hidden 속성은 렌더 트리에 포함된다. 그 이유는 visibility:hidden 속성은 렌더링이 되더라도 여전히 레이아웃에서 공간을 차지하기 때문이다.

- DOM 요소에 부합하나 1:1로 대응하지는 않는다 (ex. head와 같은 비시각적 요소, select요소 따위의 복잡성, position-float같은 다른 위치의 요소들)

<br/><br/>
**3. 렌더 트리 배치 (Layout & Reflow)**

렌더 트리는 DOM 트리와 CSSOM 트리에 의해 정의된 스타일만 계산하였다. 하지만 기기의 뷰포트(Viewport) 내에서의 정확한 위치 및 크기는 계산되지 않았다.

예를들어 CSS에 width:50% 로 정의되어 있다고 하면, 실제 브라우저에서 표현되는 정확한 사이즈는 계산되지 않았다는 의미이다.

따라서 브라우저에 출력하기 전 실제 출력되는 정확한 위치와 크기를 계산하여야 한다. 그 단계가 레이아웃 (layout) 또는 리플로우 (reflow) 단계라고 한다. 이러한 리플로우 단계에서는 각 객체의 정확한 위치 및 크기를 계산하기 위해 렌더 트리의 루트에서부터 탐색해 실제 픽셀 값을 구하여 박스 모델 (Box Model)을 출력한다.
<br/>
![image alt](https://memory.today/dev/36/box-model.png)

박스 모델의 넓이는 뷰포트 (ICB) 기준으로 측정되고, 높이는 Contents (fonts) 기준으로 측정된다. 따라서 윈도우 사이즈를 변경하거나, 폰트를 변경하면 리플로우가 다시 발생되게 되는 것이다.

<br/><br/>
**4. 렌더 트리 그리기 (Painting & Rasterizing)**

Layout에서 노드의 화면 구상이 다 이뤄지면, Paint 이벤트를 통해 노드들은 화면에 픽셀로 변환한다. 텍스트, 색, 이미지 등 모든 시각적인 요소들이 입혀진다. 이를 Painting 또는 Rasterizing 이라고 하며, Layer가 여러개인 경우 이를 합성해 하나의 bitmap을 만드는 작업은 compositing이라고 한다
<br/><br/><br/>

### 렌더링 엔진의 메인 Flow

- Webkit 엔진
  ![image alt](https://user-images.githubusercontent.com/35126809/90095491-c421a580-dd6b-11ea-9fd7-3c83e36e3913.png)  
  <br/><br/>

- Gecko 엔진
  ![image alt](https://user-images.githubusercontent.com/35126809/90095497-cc79e080-dd6b-11ea-971c-a891d0c9e55b.png)

<br/><br/><br/>

### 참고 사이트

- https://bomango.tistory.com/6?category=859680
- https://juunone.github.io/browser/
- https://upcount.tistory.com/97
- https://it-ist.tistory.com/110
- https://d2.naver.com/helloworld/59361
- https://na27.tistory.com/228
- https://poiemaweb.com/js-dom
- https://memory.today/dev/36
